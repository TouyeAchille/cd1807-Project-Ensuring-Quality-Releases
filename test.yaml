name: assurance-quality-pipeline

# Start with a minimal pipeline that you can customize to build and deploy your code.
# Add steps that build, run tests, deploy, and more:
# https://aka.ms/yaml
trigger:
- main

pool: myAgentPool

variables:
  python.version: '3.12.3'
  azureServiceConnectionId: 'myServiceConnection'
  # Project root folder. Point to the folder containing manage.py file.
  projectRoot: $(System.DefaultWorkingDirectory)
  tfWorkingDirectory: '$(System.DefaultWorkingDirectory)/terraform/environments/test'
  azureRg: 'Azuredevops' 
  containerName: 'tfstate' 
  storageAccountName: "tfstate184604487"
  blobname: 'test.terraform.tfstate'
  # Environment name
  environmentName: 'test-vm'


stages:
#--------------------------------------------#  
# BUILD STAGE
#--------------------------------------------#    
- stage: Build
  jobs:
  - job: BuildInfrastructure
    steps:
    #--------------------------------------------#  
      - script: |
          sudo apt-get update
          sudo apt-get install -y unzip
          echo "acces keys :$(ARM_ACCESS_KEY)" 
        displayName: 'Install unzip'
        env:
          ARM_ACCESS_KEY: $(ARM_ACCESS_KEY)
          PUBLIC_KEY: $(PUBLIC_KEY)
          KNOWN_HOSTS_ENTRY: $(KNOWN_HOSTS_ENTRY)
          
      # Use Terraform to create the Infrastructure      
      # Install Terraform on the pipeline agent 
      - task: TerraformInstaller@1
        displayName: 'Terrafom installation'
        inputs:
          terraformVersion: '1.13.2'
      
      # Run Terraform Init on the pipeline agent 
      - task: TerraformTask@5
        displayName: 'Terrafom init'
        inputs:
          provider: 'azurerm'
          command: 'init'
          workingDirectory: $(tfWorkingDirectory)
          backendServiceArm: '$(azureServiceConnectionId)'
          backendAzureRmResourceGroupName: '$(azureRg)'
          backendAzureRmStorageAccountName: '$(storageAccountName)'
          backendAzureRmContainerName: '$(containerName)'
          backendAzureRmKey: '$(blobname)'
          backendAzureRmUseCliFlagsForAuthentication: true
          backendAzureRmUseEntraIdForAuthentication: false
        
      # Run Terraform Validate
      - task: TerraformTask@5
        displayName: Terraform validate
        inputs:
          provider: 'azurerm'
          command: 'validate'
          environmentServiceNameAzureRM: '$(azureServiceConnectionId)'

    # OPTIONAL - This step is needed only if your Terraform VM uses an SSH key pair for login and you want your pipeline agent to connect to it. 
    # Generate an SSH key pair in your local/AZ Cloud shell. Use the public key in the Terraform VM module. 
    # Install public key and private key file to the pipeline agent, using the task below. 
    
      - task: InstallSSHKey@0
        displayName: 'Install SSH key'
        inputs:
          knownHostsEntry: '$(KNOWN_HOSTS_ENTRY)'   
          sshPublicKey: $(PUBLIC_KEY)       # You can also use a secure file here, as shown in the commented-out task below.            
          sshKeySecureFile: 'ssh-key.pem'   # Use secure file feature in the pipeline library UI to save the "id_rsa" file, as mentioned here: https://learn.microsoft.com/en-us/azure/devops/pipelines/library/secure-files?view=azure-devops#add-a-secure-file
    
    # - task: DownloadSecureFile@1
    #  name: udacity_public_key
    #  displayName: 
    #  inputs:
    #   secureFile: 'ssh-key.pem'  

      - task: TerraformTask@5
        displayName: Run Terraform Plan
        inputs:
            provider: 'azurerm'
            command: 'plan'
            commandOptions: '-out tfplan -var="ssh_public_key=$(PUBLIC_KEY)"'
            workingDirectory: '$(tfWorkingDirectory)'
            environmentServiceNameAzureRM: '$(azureServiceConnectionId)'

            # Run Terraform Apply

      - task: TerraformTask@5
        displayName: Run Terraform apply
        inputs:
          provider: 'azurerm'
          command: 'apply'
          commandOptions: 'tfplan'
          workingDirectory: '$(tfWorkingDirectory)'
          environmentServiceNameAzureRM: '$(azureServiceConnectionId)'


    # ToDo: Change the workingDirectory path, as applicable t
    # Destroy the resources in Azure by running a separate pipeline. 
    # - task: TerraformTask@5
    #   displayName: Terraform destroy
    #   inputs:
    #     provider: 'azurerm'
    #     command: 'destroy'
    #     workingDirectory: $(tfWorkingDirectory)
    #     environmentServiceNameAzureRM: '$(azureServiceConnectionId)'

